(* Lazarus+FPC 0.9.24+2.2.0 to 0.9.30+2.6.0. On Linux for ARM, PPC, SPARC, x86. *)

unit IniFilesAbout;

(* Functions to return timestamp info in various forms typically used for       *)
(* detecting things like rebuilds of the executable, and generic "About" text.  *)

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils;

type
  TIsoDateTimeFormat= (IsoDateOnly, IsoTimeOnly, IsoTimeOnlyMins, IsoDateTime,
                                                                IsoDateTTime);

const
  IsoDateTimeRoundSecs= -999;

(* Return a date and time in the ISO format. If fractionDigits is -ve or takes
  the value IsoDateTimeRoundSecs then milliseconds or seconds are rounded.
*)
function IsoFormatDateTime(dt: TDateTime; format: TIsoDateTimeFormat;
                                        fractionDigits: integer= 0): string;

(* Return a date and time in the ISO format. If fractionDigits is -ve or takes
  the value IsoDateTimeRoundSecs then milliseconds or seconds are rounded.
*)
function IsoFormatDateTime(dt: TDateTime; fractionDigits: integer= 0): string;

(* Return "Now" as an ISO-format date and time. The result may be subject to
  local timezone manipulation.
*)
FUNCTION IsoNow(format: TIsoDateTimeFormat; fractionDigits: integer= 0): STRING;

(* Return "Now" as an ISO-format date and time. The result may be subject to
  local timezone manipulation.
*)
FUNCTION IsoNow(fractionDigits: integer= 0): STRING;

(* Append "th" etc. to a number, typically a date generated by something like
  FormatDateTime('ddd d', UTC_Now()) resulting in e.g. "Tue 18th".
*)
function MakeOrdinal(const date: string): string;

(* Append "th" etc. to a number, typically a date generated by something like
  FormatDateTime('ddd d', UTC_Now()) resulting in e.g. "Tue 18th".
*)
function MakeOrdinal(const num: longword): string;

(* Return "Now" as a seconds count relative to the unix epoch (1970-01-01). The
  result will be close, but probably not identical, to that returned by IsoNow()
  above.

  For reference, these commands might be found useful:

  $ date --date='@1599929426' --rfc-3339=sec --utc
  2020-09-12 16:50:26+00:00
  $ date --date='2020-09-12 16:50:26+00:00' +%s
  1599929426
 
  Above run on a Linux system using GNU coreutils.
*)
FUNCTION UnixNow(): LONGWORD;

(* This should have the same overall behaviour as the standard Now() function,
  but removes the timezone compensation.
*)
function UTC_Now(): TDateTime;

(* This is an alternative to the RTL's Now() based on the POSIX clock if
  available otherwise falling back to Now(). It is intended to compensate for
  the fact that as timestamps move further from the epoch they are able to store
  fewer fractional bits, it is anticipated that it will be used primarily for
  interval comparisons and that the operating environment will not change during
  program execution in a way that would cause clock_gettime() to stop working.

  Note that this relies on the extended (10-byte real) type for precision, and
  as such will have portability issues.
*)
function PosixSecs(): extended; platform;

(* Return the build date and time, corrected to ISO format. The result may be
  subject to timezone manipulation as determined by the locale and DST state
  when the program was built, assume that the precision is limited to 1 second
  so control of the number of fraction bits is irrelevant.
*)
FUNCTION IsoBuild(format: TIsoDateTimeFormat=IsoDateTime): STRING;

(* Return the build date and time as a seconds count relative to the unix epoch
  (1970-01-01). The result will be a representation of that returned by
  IsoBuild() above.
*)
FUNCTION UnixBuild(): LONGWORD;

(* If the (cached) build ID (GNU ld --build-id option) is available use it,
  otherwise if the (cached) Lazarus project version is available squash it to
  32-bits and use it, otherwise use the build date which is known to be a
  32-bit timestamp.
*)
FUNCTION BuildId32(): LONGWORD;

(* If the (cached) build ID (GNU ld --build-id option) is available use it,
  otherwise if the (cached) project version is available use it, otherwise use
  the build date.
*)
FUNCTION BuildId64(): QWORD;

(* Return the date/time of a file's last modification, assume that the precision
  is limited by the filesystem to 1 second so control of the number of fraction
  bits is irrelevant.
*)
FUNCTION IsoModified(CONST name: STRING; format: TIsoDateTimeFormat=IsoDateTime): STRING;

(* Return the date/time of a file's last modification, assume that the precision
  is limited by the filesystem to 1 second so control of the number of fraction
  bits is irrelevant.
*)
FUNCTION IsoModified(handle: THandle; format: TIsoDateTimeFormat=IsoDateTime): STRING;

(* Return the date/time of a file's last modification, assume that the precision
  is limited by the filesystem to 1 second so control of the number of fraction
  bits is irrelevant.
*)
FUNCTION IsoModified(VAR f: FILE; format: TIsoDateTimeFormat=IsoDateTime): STRING;

(* Return the date/time of a file's last modification, assume that the precision
  is limited by the filesystem to 1 second so control of the number of fraction
  bits is irrelevant.
*)
FUNCTION IsoModified(VAR t: TEXT; format: TIsoDateTimeFormat=IsoDateTime): STRING;

(* Return the date/time of a file's last modification.
*)
FUNCTION UnixModified(CONST name: STRING): LONGWORD;

(* Return the date/time of a file's last modification.
*)
FUNCTION UnixModified(handle: THandle): LONGWORD;

(* Return the date/time of a file's last modification.
*)
FUNCTION UnixModified(VAR f: FILE): LONGWORD;

(* Return the date/time of a file's last modification.
*)
FUNCTION UnixModified(VAR t: TEXT): LONGWORD;

(* Return the screen/display number for unix, and the windowstation identifier
  or similar for Windows. Do not assume the result is numeric.
*)
FUNCTION DisplayIdentifier(): STRING;

(* Everything you wanted to know about the program (but were afraid to ask).
*)
FUNCTION AboutText(CONST appendage: STRING= ''; CONST vcsId: STRING= ''): STRING;

(* Everything you wanted to know about the program (but were afraid to ask).
*)
FUNCTION AboutText(CONST appendage: ARRAY OF STRING; CONST separator: STRING= '';
                                        CONST vcsId: STRING= ''): STRING;

(* This is the RTL's Format(), with the following enhancements:

    %I    ISO-format date and time.
    %0I   ISO-format uncorrected data and time, i.e. UTC on most unix systems.
    %U    Decimal seconds since 1970-01-01 00:00:00.
    %0U   Decimal seconds since 1970-01-01 00:00:00, always assumed to be UTC.
    \a    Alert (bell) character. Interpretation and redirection is OS-specific
    \A    If MIDI is available, a suitable tone provided that $DISPLAY is local
    \n    Expands to LF (irrespective of operating system).
    \N    Expands to end-of-line (subject to operating system).
    \r    Expands to CR.
    \t    Expands to a single tab character.
    \T    Uses spaces to pad the preceding text to a tab position.
    \1T   Outputs a single space, then spaces to column 9 if necessary.
    \2T   Outputs a single space, then spaces to column 17 if necessary.
    \nT   As above, output a space and then pad to a tab position if necessary.
          In all cases, n must be a single digit, 0 is interpreted as 10.
    \n.xT Output x spaces after tab position n. \9.5T| puts a bar at column 78
          which, if followed by CR LF, fills an 80 character record.
    \\  Literal backslash.

  Note the distinction between the two special cases %0I and %0U, which are not
  standard Format() or printf() patterns, as compared with %0:i and %0:u which
  are. The final two optional parameters are applicable only to ISO-format
  dates.
*)
function FormatEx(const str: string; values: array of const;
                                        format: TIsoDateTimeFormat;
                                        fractionDigits: integer= 0): string;

(* This is the RTL's Format(), with the following enhancements:

    %I    ISO-format date and time.
    %0I   ISO-format uncorrected data and time, i.e. UTC on most unix systems.
    %U    Decimal seconds since 1970-01-01 00:00:00.
    %0U   Decimal seconds since 1970-01-01 00:00:00, always assumed to be UTC.
    \a    Alert (bell) character. Interpretation and redirection is OS-specific
    \A    If MIDI is available, a suitable tone provided that $DISPLAY is local
    \n    Expands to LF (irrespective of operating system).
    \N    Expands to end-of-line (subject to operating system).
    \r    Expands to CR.
    \t    Expands to a single tab character.
    \T    Uses spaces to pad the preceding text to a tab position.
    \1T   Outputs a single space, then spaces to column 9 if necessary.
    \2T   Outputs a single space, then spaces to column 17 if necessary.
    \nT   As above, output a space and then pad to a tab position if necessary.
          In all cases, n must be a single digit, 0 is interpreted as 10.
    \n.xT Output x spaces after tab position n. \9.5T| puts a bar at column 78
          which, if followed by CR LF, fills an 80 character record.
    \\  Literal backslash.

  Note the distinction between the two special cases %0I and %0U, which are not
  standard Format() or printf() patterns, as compared with %0:i and %0:u which
  are. The final optional parameter is applicable only to ISO-format dates.
*)
function FormatEx(const str: string; values: array of const;
                                        fractionDigits: integer= 0): string;


implementation

(*$IFDEF LCL *)

  (* If a widget set is defined then we can access the Screen object in the Forms *)
  (* unit.                                                                        *)

  (*$IFDEF DELPHI	*)
    (*$DEFINE HAS_SCREEN *)
  (*$ENDIF	*)
  (*$IFDEF LCLWIN32 *)
    (*$DEFINE HAS_SCREEN *)
  (*$ENDIF       *)
  (*$IFDEF LCLGTK *)
    (*$DEFINE HAS_SCREEN *)
  (*$ENDIF       *)
  (*$IFDEF LCLGTK2 *)
    (*$DEFINE HAS_SCREEN *)
  (*$ENDIF       *)
  (*$IFDEF LCLQT *)
    (*$DEFINE HAS_SCREEN *)
  (*$ENDIF       *)
  (*$IFDEF LCLFPGUI *)
    (*$DEFINE HAS_SCREEN *)
  (*$ENDIF       *)

(* The LCLVersion unit was added at Lazarus (strictly, the LCL) 0.9.24.1, i.e.  *)
(* it is present in the fixes branch but not in the original. Assume that if    *)
(* the underlying FPC is 2.2.2 (the oldest version available as a binary due to *)
(* IP issues) that the unit is available, otherwise (i.e. for compilers 2.2.0   *)
(* or older) that it is not. lcl_fullversion was not initially defined, I've    *)
(* added lcl_fullversion2 lest the 0.9 beta runs to more than patchlevel 99.    *)
(* The fcl-res package is available from 2.4.0, as is exeinfo in the RTL.       *)

  (*$DEFINE HAS_LCLVERSION    *)        (* NOTE: LCL is a prerequisite          *)
(*$ENDIF LCL *)

(*$DEFINE HAS_FCLRES        *)
(*$IFDEF VER1   *)
  (*$UNDEF HAS_LCLVERSION   *)
  (*$UNDEF HAS_FCLRES       *)
(*$ENDIF        *)
(*$IFDEF VER2_0 *)
  (*$UNDEF HAS_LCLVERSION   *)
  (*$UNDEF HAS_FCLRES       *)
(*$ENDIF        *)
(*$IFDEF VER2_1 *)
  (*$UNDEF HAS_LCLVERSION   *)
  (*$UNDEF HAS_FCLRES       *)
(*$ENDIF        *)
(*$IFDEF VER2_2 *)
  (*$IFDEF VER2_2_0 *)
    (*$UNDEF HAS_LCLVERSION *)
  (*$ENDIF          *)
  (*$IFDEF VER2_2_1 *)
    (*$UNDEF HAS_LCLVERSION *)
  (*$ENDIF          *)
  (*$UNDEF HAS_FCLRES       *)

(* Anything later hopefully equivalent to Lazarus/LCL 0.9.24.1 or better.       *)

(*$ENDIF        *)

USES (*$ifdef HAS_SCREEN *) Forms, Graphics, (*$endif HAS_SCREEN *) DateUtils
        (*$IFDEF HAS_LCLVERSION *) , LCLVersion (*$ENDIF HAS_LCLVERSION *)
        (*$IFDEF HAS_FCLRES *) , resource, versiontypes, versionresource
        (*$ENDIF HAS_FCLRES *) , exeinfo {$ifdef UNIX} , Linux, BaseUnix, UnixUtil {$endif } ;

(*$IFDEF LCL *)
  (*$IFDEF HAS_LCLVERSION *)            (* NOTE: LCL is a prerequisite          *)
CONST   lcl_major = LCLVersion.lcl_major;
        lcl_minor = LCLVersion.lcl_minor;
        lcl_release = LCLVersion.lcl_release;
        lcl_patch = LCLVersion.lcl_patch;
        lcl_version = LCLVersion.lcl_version;
  (*$ELSE                 *)
CONST   lcl_major = 0;
        lcl_minor = 9;
  (*$IFDEF VER2_2   	*)
        lcl_release = 24;
        lcl_version = '0.9.24.0';
  (*$ELSE                 *)
        lcl_release = 18;               (* To be refined.                       *)
        lcl_version = '0.9.18.0';
  (*$ENDIF                *)
        lcl_patch = 0;
  (*$ENDIF                *)
        {%H- 5028 } lcl_fullversion = ((lcl_major *  100 + lcl_minor) * 100 + lcl_release) * 100 + lcl_patch;
        {%H- 5028 } lcl_fullversion2 = ((lcl_major *  1000 + lcl_minor) * 1000 + lcl_release) * 1000 + lcl_patch;
(*$ENDIF LCL *)

(* Remember that this should only appear once in a program in case %TIME% or    *)
(* %DATE% increments during compilation.                                        *)

CONST   manifestDate= (*$I %DATE% *) ;
        manifestTime= (*$I %TIME% *) ;
        eol= #$0D + #$0A;
        uncached= QWORD($ffffffffffffffff);
        isoD=   'yyyy-mm-dd';
        isoT=   'hh":"nn":"ss';
        isoTm=  'hh":"nn';
        isoDT=  'yyyy-mm-dd hh":"nn":"ss';
        isoDTT= 'yyyy-mm-ddThh":"nn":"ss';

VAR     cachedResourceVersion: QWORD= uncached;
        cachedBuildId: QWORD= uncached;


(* Return a date and time in the ISO format. If fractionDigits is -ve or takes
  the value IsoDateTimeRoundSecs then milliseconds or seconds are rounded.
*)
function IsoFormatDateTime(dt: TDateTime; format: TIsoDateTimeFormat;
                                        fractionDigits: integer= 0): string;

(* Originally split out to help testing .z, which FPC to at least v3 screws     *)
(* totally since it treats the decimal point as a separator and doesn't pad and *)
(* round based on the number of z specifiers.                                   *)

var
  pattern: string;
  millisecs: integer;
  roundSecs: boolean;


  function roundOrTrunc(f: double): integer;

  begin
    if roundSecs then
      roundOrTrunc := Round(f)
    else
      roundOrTrunc := Trunc(f)
  end { roundOrTrunc } ;


BEGIN
  case format of
    IsoDateOnly:     pattern := isoD;
    IsoTimeOnly:     pattern := isoT;
    IsoTimeOnlyMins: pattern := isoTm;  (* Never rounds minutes                 *)
    IsoDateTime:     pattern := isoDT
  otherwise
    pattern := isoDTT
  end;
  roundSecs := fractionDigits < 0;      (* Assumes IsoDateTimeRoundSeconds -ve  *)
  if fractionDigits = IsoDateTimeRoundSecs then
    fractionDigits := 0
  else
    fractionDigits := Abs(fractionDigits);
  if fractionDigits > 3 then
    fractionDigits := 3;
  milliSecs := Trunc(1000.0 * Frac(dt / OneSecond));
  if roundSecs and (fractionDigits = 0) and (milliSecs >= 500) then
    dt += OneSecond;
  result := FormatDateTime(pattern, dt);
  if (format <> isoDateOnly) and (fractionDigits > 0) then begin
    result += '.';
    case fractionDigits of              (* Should see cases 1..3 only           *)
      1: result += IntToStr(roundOrTrunc(milliSecs / 100));
      2: begin
           if milliSecs / 10 < 10 then
             result += '0';
           result += IntToStr(roundOrTrunc(milliSecs / 10))
         end
    otherwise
      if milliSecs < 100 then
        result += '0';
      if milliSecs < 10 then
        result += '0';
      result += IntToStr(milliSecs)
    end
  end
END { IsoFormatDateTime } ;


(* Return a date and time in the ISO format. If fractionDigits is -ve or takes
  the value IsoDateTimeRoundSecs then milliseconds or seconds are rounded.
*)
function IsoFormatDateTime(dt: TDateTime; fractionDigits: integer= 0): string;

begin
  result := IsoFormatDateTime(dt, IsoDateTime, fractionDigits)
end { IsoFormatDateTime } ;


{$ifopt C+ Predicated on assertions generating code }

(* Test cases known to behave badly with the standard FPC functions.
*)
procedure testIso;

var
  testThis: TDateTime;
  scratch: string;

begin

(* Small numbers of millisecs should have no effect if milliseconds are not to  *)
(* be displayed.                                                                *)

  testThis := UnixToDateTime(0);
  scratch := IsoFormatDateTime(testThis);               (* 00:00:00             *)
  testThis := UnixToDateTime(0) + OneMillisecond;
  scratch := IsoFormatDateTime(testThis);               (* 00:00:00             *)
  testThis := UnixToDateTime(0) + OneMillisecond * 10;
  scratch := IsoFormatDateTime(testThis);               (* 00:00:00             *)

(* 10 milliseconds is not, under any circumstances whatsoever, 0.1 of a second. *)

  testThis := UnixToDateTime(0) + OneMillisecond * 10;
  scratch := IsoFormatDateTime(testThis, 1);            (* 00:00:00.0           *)
  testThis := UnixToDateTime(0) + OneMillisecond * 10;
  scratch := IsoFormatDateTime(testThis, 2);            (* 00:00:00.01          *)
  testThis := UnixToDateTime(0) + OneMillisecond * 10;
  scratch := IsoFormatDateTime(testThis, 3);            (* 00:00:00.010         *)
  testThis := UnixToDateTime(0) + OneMillisecond * 100;
  scratch := IsoFormatDateTime(testThis);               (* 00:00:00             *)

(* 400 millisecs should round down, 600 millisecs optionally rounds up.         *)

  testThis := UnixToDateTime(0) + OneMillisecond * 400;
  scratch := IsoFormatDateTime(testThis);               (* 00:00:00             *)
  testThis := UnixToDateTime(0) + OneMillisecond * 600;
  scratch := IsoFormatDateTime(testThis);               (* 00:00:00             *)
  scratch := IsoFormatDateTime(testThis, IsoDateTimeRoundSecs); (* 00:00:01     *)

(* With tenths of seconds being displayed, 600 millisecs should never round up  *)
(* but 650 millisecs should round to 0.7 seconds. Watch out for division        *)
(* imprecision afflicting the test values.                                      *)

  testThis := UnixToDateTime(0) + OneMillisecond * 601;
  scratch := IsoFormatDateTime(testThis, 1);            (* 00:00:00.6           *)
  scratch := IsoFormatDateTime(testThis, -1);           (* 00:00:00.6           *)
  testThis := UnixToDateTime(0) + OneMillisecond * 651;
  scratch := IsoFormatDateTime(testThis, 1);            (* 00:00:00.6           *)
  scratch := IsoFormatDateTime(testThis, -1);           (* 00:00:00.7           *)
  scratch := FormatEx('%I, ', [], 1);   (* Tests IsoFormatDateTime(Now())       *)
  scratch += FormatEx('%0IZ', [], 1);   (* Tests IsoFormatDateTime(UTC_Now())   *)
  scratch := scratch                    (* Make sure we can read the result     *)
end { testIso } ;

{$endif }


(* Return "Now" as an ISO-format date and time. The result may be subject to
  local timezone manipulation.
*)
FUNCTION IsoNow(format: TIsoDateTimeFormat; fractionDigits: integer= 0): STRING;

BEGIN
  result := IsoFormatDateTime(Now(), format, fractionDigits)
END { IsoNow } ;


(* Return "Now" as an ISO-format date and time. The result may be subject to
  local timezone manipulation.
*)
FUNCTION IsoNow(fractionDigits: integer= 0): STRING;

begin
  result := IsoNow(IsoDateTime, fractionDigits)
end { IsoNow } ;


(* Append "th" etc. to a number, typically a date generated by something like
  FormatDateTime('ddd d', UTC_Now()) resulting in e.g. "Tue 18th".
*)
function MakeOrdinal(const date: string): string;

begin
  result := date;
  if (Length(result) = 1) or (result[Length(result) - 1] <> '1') THEN
    case result[Length(result)] of
      '1': result += 'st';
      '2': result += 'nd';
      '3': result += 'rd'
    otherwise
      result += 'th'
    end
  else
    result += 'th'
end { MakeOrdinal } ;


(* Append "th" etc. to a number, typically a date generated by something like
  FormatDateTime('ddd d', UTC_Now()) resulting in e.g. "Tue 18th".
*)
function MakeOrdinal(const num: longword): string;

begin
  result := MakeOrdinal(IntToStr(num))
end { MakeOrdinal } ;


(* Return "Now" as a seconds count relative to the unix epoch (1970-01-01). The
  result will be close, but probably not identical, to that returned by IsoNow()
  above.

  For reference, these commands might be found useful:

  $ date --date='@1599929426' --rfc-3339=sec --utc
  2020-09-12 16:50:26+00:00
  $ date --date='2020-09-12 16:50:26+00:00' +%s
  1599929426
 
  Above run on a Linux system using GNU coreutils.
*)
FUNCTION UnixNow(): LONGWORD;

BEGIN
  RESULT:= DateTimeToUnix(Now())
END { UnixNow } ;


(* This should have the same overall behaviour as the standard Now() function,
  but removes the timezone compensation.
*)
function UTC_Now(): TDateTime;

begin
  result := Now() - (TZSeconds / SecsPerDay)
end { UTC_Now } ;


(* This is an alternative to the RTL's Now() based on the POSIX clock if
  available otherwise falling back to Now(). It is intended to compensate for
  the fact that as timestamps move further from the epoch they are able to store
  fewer fractional bits, it is anticipated that it will be used primarily for
  interval comparisons and that the operating environment will not change during
  program execution in a way that would cause clock_gettime() to stop working.

  Note that this relies on the extended (10-byte real) type for precision, and
  as such will have portability issues.
*)
function PosixSecs(): extended; platform;

const
  useGettime= true;

var
  ts: timespec;

begin
  if useGettime and (clock_gettime(CLOCK_REALTIME, @ts) = 0) then begin
    result := ts.tv_sec;
    result += (ts.tv_nsec / 1E9)

(* Since even the extended type doesn't really have enough digits to express *)
(* times relative to the unix epoch in nanoseconds, assume we have to be     *)
(* very careful with the evaluation order.                                   *)

  end else begin
    result := Sysutils.Now();
    result -= UnixEpoch;
    result *= SecsPerDay
  end
end { PosixSecs } ;


(* Return the build date and time, corrected to ISO format. The result may be
  subject to timezone manipulation as determined by the locale and DST state
  when the program was built, assume that the precision is limited to 1 second
  so control of the number of fraction bits is irrelevant.
*)
FUNCTION IsoBuild(format: TIsoDateTimeFormat=IsoDateTime): STRING;

CONST     build= manifestDate + ' ' + manifestTime;

VAR     i: INTEGER;

BEGIN
  RESULT:= build;
  FOR i:= 1 TO Length(RESULT) DO begin
    IF RESULT[i] = '/' THEN
      RESULT[i]:= '-';
    if (result[i] = ' ') and (format = IsoDateTTime) then
      result[i] := 'T'
  end
END { IsoBuild } ;


(* Return the build date and time as a seconds count relative to the unix epoch
  (1970-01-01). The result will be a representation of that returned by
  IsoBuild() above.
*)
FUNCTION UnixBuild(): LONGWORD;

(* Test this using something like  date +%s -d '2015-10-26 07:54:38'            *)

BEGIN
  RESULT:= DateTimeToUnix(ScanDateTime(isoDT, IsoBuild))
END { UnixBuild } ;


(* Unlike most of AboutText (below), this takes significant activity at run-
  time to extract version/release/build numbers from resource information
  appended to the binary. The result is cached and returned as four 16-bit
  numbers concatenated as 64 bits, beware of potential overflow problems if
  the MSB is subsequently interpreted as a sign.
*)
FUNCTION resourceVersionInfo(): QWORD;


(* Written with reference to http://lists.lazarus.freepascal.org/pipermail/lazarus/attachments/20100723/8db6b97e/attachment.ksh *)

(*$IFDEF HAS_FCLRES *)
VAR     Stream: TResourceStream;
        vr: TVersionResource;
        fi: TVersionFixedInfo;
(*$ENDIF            *)

BEGIN
  IF cachedResourceVersion <> uncached THEN
    EXIT(cachedResourceVersion);

  RESULT:= 0;
(*$IFDEF HAS_FCLRES *)
  TRY

(* This raises an exception if version info has not been incorporated into the  *)
(* binary (Lazarus Project -> Project Options -> Version Info -> Version        *)
(* numbering).                                                                  *)

    Stream:= TResourceStream.CreateFromID(HINSTANCE, 1, PChar(RT_VERSION));
    TRY
      vr:= TVersionResource.Create;
      TRY
        vr.SetCustomRawDataStream(Stream);
        fi:= vr.FixedInfo;              (* Assume unsigned numbers here         *)
        RESULT := QWORD(fi.FileVersion[0]) SHL 48 + QWORD(fi.FileVersion[1]) SHL 32 +
                        QWORD(fi.FileVersion[2]) SHL 16 + fi.FileVersion[3];
        vr.SetCustomRawDataStream(nil)
      FINALLY
        vr.Free
      END
    FINALLY
      Stream.Free
    END
  EXCEPT
  END;
(*$ENDIF            *)
  cachedResourceVersion:= RESULT
END { resourceVersionInfo } ;


(* The lower bits of the value stored in the executable file in response to the
  (GNU) linker --build-id option, zero if this is not available.
*)
FUNCTION buildId(): QWORD;

TYPE    tIdBuff= RECORD
                   header: ARRAY[0..3] OF LONGWORD;
                   data: ARRAY[0..31] OF BYTE
                 END;
                 
VAR     binfile: TExeFile;
        secOfs, secLen, i: LONGINT;
        idBuff: tIdBuff;

BEGIN
  IF cachedBuildId <> uncached THEN
    EXIT(cachedBuildId);

  RESULT:= 0;
  cachedBuildId := 0;
  IF OpenExeFile(binFile, ParamStr(0)) THEN TRY
    IF NOT FindExeSection(binFile, '.note.gnu.build-id', secOfs, secLen) THEN
      EXIT;                             (* No build ID in file                  *)
    IF secOfs + SecLen > binFile.size THEN
      EXIT;                             (* Sanity check, via FINALLY block      *)
    IF secLen > SizeOf(idBuff) THEN
      secLen := SizeOf(idBuff);
    FillByte(idBuff, SizeOf(idBuff), 0);
    TRY
(*$PUSH *)                              (* Disable this in very old FPC versions *)
(*$I-   *)
      Seek(binFile.f, secOfs);          (* Record size 1 assumed, check reset() *)
      BlockRead(binFile.f, idBuff, secLen, i)
(* I+   *)                              (* Enable this in very old FPC versions *)
(*$POP  *)                              (* Disable this in very old FPC versions *)
    EXCEPT
      EXIT                              (* For older versions, via FINALLY block *)
    END;
    IF i <> secLen THEN                 (* Short read, use timestamp instead    *)
      EXIT;                             (* Via FINALLY block                    *)

(* I've not checked this in all possible cases (in particular, with either GNU  *)
(* or native ld on Solaris and OSX), but I believe that the first 16 bytes of   *)
(* at least this section type is a header. On a 32-bit little-endian system     *)
(* (Linux x86) if the build ID is set to 12345678 the binary looks like this:   *)
(*                                                                              *)
(* 0000120:                     0400 0000 0400 0000          ........           *)
(* 0000130: 0300 0000 474e 5500 1234 5678            ....GNU..4Vx               *)
(*                                                                              *)
(* while if it is set to 1234567887654321 it looks like:                        *)
(*                                                                              *)
(* 0000120:                     0400 0000 0800 0000          ........           *)
(* 0000130: 0300 0000 474e 5500 1234 5678 8765 4321  ....GNU..4Vx.eC!           *)
(*                                                                              *)
(* 64-bit little-endian (Linux x86_64), 12345678 and 1234567887654321:          *)
(*                                                                              *)
(* 0000200:           0400 0000 0400 0000 0300 0000      ............           *)
(* 0000210: 474e 5500 1234 5678                      GNU..4Vx                   *)
(*                                                                              *)
(* 0000200:           0400 0000 0800 0000 0300 0000      ............           *)
(* 0000210: 474e 5500 1234 5678 8765 4321            GNU..4Vx.eC!               *)
(*                                                                              *)
(* 32-bit big-endian (Linux SPARC), 12345678 and 1234567887654321:              *)
(*                                                                              *)
(* 0000120:                     0000 0004 0000 0004          ........           *)
(* 0000130: 0000 0003 474e 5500 1234 5678            ....GNU..4Vx               *)
(*                                                                              *)
(* 0000120:                     0000 0004 0000 0008          ........           *)
(* 0000130: 0000 0003 474e 5500 1234 5678 8765 4321  ....GNU..4Vx.eC!           *)
(*                                                                              *)
(* So the order of the header's numeric fields conforms to native endianness,   *)
(* while the GNU string and payload are byte-by-byte. Any ordering issues       *)
(* related to SHA-1 etc. ordering are outside the scope of this function,       *)
(* provided that an explicit (hex) parameter passed using --build-id is always  *)
(* retrieved correctly.                                                         *)

(* Up to this point, assume that the appropriate thing is to fail gracefully if *)
(* the file can't be read, there isn't a build ID section, or we have trouble   *)
(* reading the file. Now that the section is in memory, use assertions to make  *)
(* errors prominent during development.                                         *)

    Assert(idBuff.header[0] = 4, 'Build ID section header length wrong');
    IF idBuff.header[0] <> 4 THEN        (* Length of header in words           *)
      EXIT;
    Assert(idBuff.header[1] <= 32, 'Build ID using unknown hash type (> 256 bits)');
    Assert(idBuff.header[1] <= secLen - 16, 'Build ID section header content overflow');
    Assert(idBuff.header[1] > 0, 'Build ID section header content underflow');
    IF idBuff.header[1] > secLen - 16 THEN (* Length of content in bytes        *)
      EXIT;
    Assert(idBuff.header[2] = 3, 'Build ID section header magic length wrong');
    IF idBuff.header[2] <> 3 THEN        (* Length of 'GNU' string in bytes?    *)
      EXIT;
(*$IFDEF ENDIAN_LITTLE *)
    Assert(idBuff.header[3] = $00554E47, 'Build ID section header LE magic wrong');
    IF idBuff.header[3] <> $00554E47 THEN
      EXIT;
(*$ELSE                *)
    Assert(idBuff.header[3] = $474E5500, 'Build ID section header BE magic wrong');
    IF idBuff.header[3] <> $474E5500 THEN
      EXIT;
(*$ENDIF ENDIAN_LITTLE *)

(* Compute an offset and length for the transfer, bearing in mind that we want  *)
(* the less significant 64 bits so can't just start at idBuff.data[0].          *)

    secOfs := 0;
    IF idBuff.header[1] > 8 THEN
      secOfs := idBuff.header[1] - 8;
    secLen := idBuff.header[1];         (* Maximum 8 bytes here                 *)
    IF secLen > 8 THEN
      secLen := 8;
    RESULT := 0;
    FOR i := secOfs TO secOfs + secLen - 1 DO (* Shift in up to 8 bytes         *)
      RESULT := (RESULT SHL 8) + idBuff.data[i];
    cachedBuildId := RESULT
  FINALLY
    CloseExeFile(binFile)
  END
END { buildId } ;


(* If the (cached) build ID (GNU ld --build-id option) is available use it,
  otherwise if the (cached) Lazarus project version is available squash it to
  32-bits and use it, otherwise use the build date which is known to be a
  32-bit timestamp.
*)
FUNCTION BuildId32(): LONGWORD;

(* The rationale for this order is that while the timestamp is a better "magic  *)
(* number" than the version information, it's useful to be able to force in a   *)
(* fixed value for debugging. This is particularly significant when working     *)
(* with something like Solaris where the native linker might be preferable to   *)
(* the GNU one: even though we don't have the --build-id option, we can still   *)
(* set the version to something fixed.                                          *)

VAR     rv64: QWORD;

BEGIN
  IF buildId <> 0 THEN
    RESULT := LONGWORD(buildId and $ffffffff)
  ELSE
    IF resourceVersionInfo <> 0 THEN BEGIN
      rv64 := resourceVersionInfo;
      RESULT := rv64 AND $ff;
      rv64 := rv64 SHR 16;
      RESULT := RESULT + (rv64 AND $ff) SHL 8;
      rv64 := rv64 SHR 16;
      RESULT := RESULT + (rv64 AND $ff) SHL 16;
      rv64 := rv64 SHR 16;
      RESULT := RESULT + (rv64 AND $ff) SHL 24
    END ELSE
      RESULT := UnixBuild
END { BuildId32 } ;


(* If the (cached) build ID (GNU ld --build-id option) is available use it,
  otherwise if the (cached) project version is available use it, otherwise use
  the build date.
*)
FUNCTION BuildId64(): QWORD;

(* The rationale for this order is that while the timestamp is a better "magic  *)
(* number" than the version information, it's useful to be able to force in a   *)
(* fixed value for debugging. This is particularly significant when working     *)
(* with something like Solaris where the native linker might be preferable to   *)
(* the GNU one: even though we don't have the --build-id option, we can still   *)
(* set the version to something fixed.                                          *)

BEGIN
  IF buildId <> 0 THEN
    RESULT := buildId
  ELSE
    IF resourceVersionInfo <> 0 THEN
      RESULT := resourceVersionInfo
    ELSE
      RESULT := UnixBuild
END { BuildId64 } ;


(* Return the date/time of a file's last modification, assume that the precision
  is limited by the filesystem to 1 second so control of the number of fraction
  bits is irrelevant.
*)
FUNCTION IsoModified(CONST name: STRING; format: TIsoDateTimeFormat=IsoDateTime): STRING;

BEGIN
  TRY
    RESULT:= IsoFormatDateTime(FileDateToDateTime(FileAge(name)), format, 0)
  EXCEPT
    RESULT:= '[undated]'
  END
END { IsoModified } ;


(* Return the date/time of a file's last modification, assume that the precision
  is limited by the filesystem to 1 second so control of the number of fraction
  bits is irrelevant.
*)
FUNCTION IsoModified(handle: THandle; format: TIsoDateTimeFormat=IsoDateTime): STRING;

BEGIN
  TRY
    RESULT:= IsoFormatDateTime(FileDateToDateTime(FileGetDate(handle)), format, 0)
  EXCEPT
    RESULT:= '[undated]'
  END
END { IsoModified } ;


(* Return the date/time of a file's last modification, assume that the precision
  is limited by the filesystem to 1 second so control of the number of fraction
  bits is irrelevant.
*)
FUNCTION IsoModified(VAR f: FILE; format: TIsoDateTimeFormat=IsoDateTime): STRING;

BEGIN
  RESULT:= IsoModified(FileRec(f).Handle, format)
END { IsoModified } ;


(* Return the date/time of a file's last modification, assume that the precision
  is limited by the filesystem to 1 second so control of the number of fraction
  bits is irrelevant.
*)
FUNCTION IsoModified(VAR t: TEXT; format: TIsoDateTimeFormat=IsoDateTime): STRING;

BEGIN
  RESULT:= IsoModified(TextRec(t).Handle, format)
END { IsoModified } ;


(* Return the date/time of a file's last modification.
*)
FUNCTION UnixModified(CONST name: STRING): LONGWORD;

BEGIN
  TRY
    RESULT:= DateTimeToUnix(FileDateToDateTime(FileAge(name)))
  EXCEPT
    RESULT:= $FFFFFFFF
  END
END { UnixModified } ;


(* Return the date/time of a file's last modification.
*)
FUNCTION UnixModified(handle: THandle): LONGWORD;

BEGIN
  TRY
    RESULT:= DateTimeToUnix(FileDateToDateTime(FileGetDate(handle)))
  EXCEPT
    RESULT:= $FFFFFFFF
  END
END { UnixModified } ;


(* Return the date/time of a file's last modification.
*)
FUNCTION UnixModified(VAR f: FILE): LONGWORD;

BEGIN
  RESULT:= UnixModified(FileRec(f).Handle)
END { UnixModified } ;


(* Return the date/time of a file's last modification.
*)
FUNCTION UnixModified(VAR t: TEXT): LONGWORD;

BEGIN
  RESULT:= UnixModified(TextRec(t).Handle)
END { UnixModified } ;


(* Return the screen/display number for unix, and the windowstation identifier
  or similar for Windows. Do not assume the result is numeric.
*)
FUNCTION DisplayIdentifier(): STRING;

(* The screen object started to publish the monitor number around 0.9.28, i.e.  *)
(* corresponding to FPC 2.4 rather than an earlier compiler.                    *)

(*$IFDEF VER1   *)
  (*$DEFINE NO_MONITORNUM       *)
(*$ENDIF        *)
(*$IFDEF VER2_0 *)
  (*$DEFINE NO_MONITORNUM       *)
(*$ENDIF        *)
(*$IFDEF VER2_1 *)
  (*$DEFINE NO_MONITORNUM       *)
(*$ENDIF        *)
(*$IFDEF VER2_2 *)
  (*$DEFINE NO_MONITORNUM       *)
(*$ENDIF        *)
(*$IFDEF VER2_3 *)
  (*$DEFINE NO_MONITORNUM       *)
(*$ENDIF        *)
(*$ifndef HAS_SCREEN *)
  (*$DEFINE NO_MONITORNUM       *)
(*$endif HAS_SCREEN  *)

BEGIN
  RESULT:= '[unidentified]';
(*$IFDEF UNIX   *)
  (*$IFDEF NO_MONITORNUM        *)
  RESULT:= GetEnvironmentVariable('DISPLAY');
  WHILE Pos(':', RESULT) > 0 DO
    Delete(RESULT, 1, 1);
  IF RESULT = '' THEN
    RESULT:= '[unidentified]'
  (*$ELSE                       *)
  RESULT:= IntToStr(Screen.PrimaryMonitor.MonitorNum)
  (*$ENDIF                      *)
(*$ELSE         *)

(*$ENDIF        *)
END { DisplayIdentifier } ;


(* If there appears to be good version information stored in the resources
  embedded in the executable file then format it as a string. Otherwise
  return nothing.
*)
FUNCTION resourceVersionString(): STRING;

VAR     resourceVersionBinary: QWORD;

BEGIN
  RESULT := '';
  resourceVersionBinary := resourceVersionInfo;
  IF resourceVersionBinary <> 0 THEN BEGIN
    RESULT := ' build ' + IntToStr(resourceVersionBinary AND $ffff) + eol;
    resourceVersionBinary := resourceVersionBinary SHR 16;
    RESULT := ' release ' + IntToStr(resourceVersionBinary AND $ffff) + RESULT;
    resourceVersionBinary := resourceVersionBinary SHR 16;
    RESULT := '.' + IntToStr(resourceVersionBinary AND $ffff) + RESULT;
    resourceVersionBinary := resourceVersionBinary SHR 16;
    RESULT := 'Version ' + IntToStr(resourceVersionBinary AND $ffff) + RESULT
  END
END { resourceVersionString } ;


(* Everything you wanted to know about the program (but were afraid to ask).
*)
FUNCTION AboutText(CONST appendage: STRING= ''; CONST vcsId: STRING= ''): STRING;

(* The $INCLUDE directives to get the Lazarus version and corresponding SVN     *)
(* revision are unhappy with absolute paths, they insist on paths relative to . *)
(* which is assumed to contain the project files, e.g. /usr/src/utils/list      *)
(* /list32/lazarus. The two files we need to refer to are both in /usr/local    *)
(* /share/lazarus/ide.                                                          *)
(*                                                                              *)
(* There is no equivalent for Delphi which has fewer versions and an extremely  *)
(* limited number of targets to manage.                                         *)

(* If the include below does not work check that Project -> Compiler Options is *)
(* set to $(LazarusDir)/ide or use an explicit relative path such as            *)
(* ../../../../../local/share/lazarus/ide/version.inc                           *)

(* Note that getting the svn revision assumes something like                    *)
(*                                                                              *)
(*  /bin/sh -c "echo -n \'`svnversion -n `\' >project_svnrevision.inc"          *)
(*                                                                              *)
(* in Compiler Options -> Compilation -> Execute before. However Lazarus        *)
(* 0.9.29 through 31 messes up the backslashes, instead use                     *)
(*                                                                              *)
(*  /bin/sh -c "echo -n C`svnversion -n`C |tr A-G %-+ >project_svnrevision.inc" *)
(*                                                                              *)
(* Note that this is dependant on having HAS_SVN defined in the project options.*)

(*$IFDEF SVN		*)
  (*$DEFINE USE_SVN	*)
(*$ENDIF		*)
(*$IFDEF HAS_SVN	*)
  (*$DEFINE USE_SVN	*)
(*$ENDIF		*)
(*$IFDEF HAS_SUBVERSION	*)
  (*$DEFINE USE_SVN	*)
(*$ENDIF		*)

(*$IFDEF FPC_SVN	*)
  (*$DEFINE USE_FPC_SVN	*)
(*$ENDIF		*)
(*$IFDEF HAS_FPC_SVN	*)
  (*$DEFINE USE_FPC_SVN	*)
(*$ENDIF		*)
(*$IFDEF HAS_FPC_SUBVERSION *)
  (*$DEFINE USE_FPC_SVN	*)
(*$ENDIF		*)


CONST     nowD= 'Built ' + manifestDate;
          nowT= manifestTime;
(*$IFDEF USE_SVN *)
  (*$IFDEF UNIX   *)
          rev= (*$I project_svnrevision.inc *) ;
  (*$ELSE         *)
          rev= 'unimplemented';
  (*$ENDIF        *)
(*$ELSE         *)
  (*$WARNING Subversion revision reporting requires Compiler Options -> Other -> Custom Options -dHAS_SVN *)
          rev= '';
(*$ENDIF        *)
(*$IFDEF USE_FPC_SVN *)
  (*$IFDEF UNIX   *)
          fpcRev= (*$I fpc_svnrevision.inc *) ;
  (*$ELSE         *)
          fpcRev= 'unimplemented';
  (*$ENDIF        *)
(*$ELSE         *)
  (*$WARNING Subversion revision reporting requires Compiler Options -> Other -> Custom Options -dHAS_FPC_SVN *)
          fpcRev= '';
(*$ENDIF        *)
(*$IFDEF LCL *)
          lazV= 'Lazarus IDE v' + (*$I version.inc *) ;
          lclV= 'Lazarus Class Library v' + lcl_version;
(*$ENDIF LCL *)
          fpcV= 'Free Pascal v' + (*$I %FPCVERSION% *) ;
          fpcC= ' for ' + (*$I %FPCTARGETCPU% *) ;
          fpcO= (*$I %FPCTARGETOS% *) ;

(*$IFDEF DELPHI	*)
	  widV= 'Linked with the Delphi widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF	*)
(*$IFDEF LCLWIN *)
	  widV= 'Linked with the Windows widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLWINDOWS *)
	  widV= 'Linked with the Windows widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLWINCE *)
	  widV= 'Linked with the Windows CE widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLWIN32 *)
	  widV= 'Linked with the Win-32 widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLWIN64 *)
	  widV= 'Linked with the Win-64 widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLGTK *)
	  widV= 'Linked with the GTK (v1) widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLGTK2 *)
	  widV= 'Linked with the GTK v2 widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLGTK3 *)
	  widV= 'Linked with the GTK v3 widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLCARBON *)
	  widV= 'Linked with the Carbon widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLCOCOA *)
	  widV= 'Linked with the Cocoa widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLQT *)
	  widV= 'Linked with the Qt widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLFPGUI *)
	  widV= 'Linked with the FPGUI widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLFPCUSTOM *)
	  widV= 'Linked with the custom-drawn widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLFPCUSTOMDRAWN *)
	  widV= 'Linked with the custom-drawn widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)
(*$IFDEF LCLNOGUI *)
	  widV= 'Linked with the No-GUI widget set';
  (*$DEFINE WIDGETSET *)
(*$ENDIF       *)

(* If there isn't enough build-time information on the LCL/widgetset type to    *)
(* generate a "Linked with" message, a "Running with" message might be appended *)
(* at run-time.                                                                 *)

(* If the include below fails check that Project -> Compiler Options -> Include *)
(* Files is set to $(LazarusDir)/ide or use an explicit relative path such as   *)
(* ../../../../../local/share/lazarus/ide/revision.inc                          *)

(*$IFDEF LCL *)
(*$I revision.inc *)
(*$ENDIF LCL *)

(* The Lazarus %DATE% macro is ordered as ISO but uses / instead of the         *)
(* preferred - so about1 is tacked onto the string at runtime after being       *)
(* sanitized, this also allows us to tack in the project's SVN revision if      *)
(* appropriate.                                                                 *)

          about1= nowD + ' ' + nowT + eol;
(*$IFDEF LCL *)
          about2a= lazV + ' revision ' + RevisionStr + eol;
          about2b= lazV + eol;
          about3= lclV + eol;
(*$ENDIF LCL *)
          about4= fpcV;
          about5= fpcC + ' ' + fpcO + eol;
(*$IFDEF WIDGETSET *)
	  about6= widV;
(*$ELSE		*)
	  about6= '';
(*$ENDIF	*)


  FUNCTION sanitize(str: STRING): STRING;

  (* Date is already ISO-ordered, force in the correct separator.               *)

  VAR   i: INTEGER;

  BEGIN
    FOR i:= 1 TO Length(str) DO
      IF str[i] = '/' THEN
        str[i]:= '-';
    RESULT:= str
  END { sanitize } ;


  FUNCTION sanitizeVcs(str: STRING): STRING;

  (* If this were C and the VCS were set up with e.g. the svn:keywords peoperty	*)
  (* we'd expect to see something like						*)
  (*										*)
  (* $Id: port-mirroring.c 30 2018-06-18 10:02:03Z markMLl $			*)
  (*										*)
  (* Chop the leading and trailing markers and the filename.			*)

  BEGIN
    WHILE (str <> '') and (str[1] <> ' ') do
      Delete(str, 1, 1);
    WHILE (str <> '') and (str[Length(str)] <> ' ') do
      Delete(str, Length(str), 1);
    str := Trim(str);
    WHILE (str <> '') and (str[1] <> ' ') do
      Delete(str, 1, 1);
    RESULT := Trim(str)
  END { sanitizeVcs } ;


  FUNCTION svn(str: STRING): STRING;

  (* Append SubVersion revision information if available. This might be a       *)
  (* number or two numbers separated by a colon, in either case followed by one *)
  (* or more letter flags.                                                      *)

  BEGIN
    IF (rev = 'exported') or (Pos('Unversioned', rev) = 1) or (rev = '') THEN
      RESULT:= str
    else
      RESULT:= TrimRight(str) + ' revision ' + rev + eol
  END { svn } ;


  FUNCTION fpcSvn(str: STRING): STRING;

  (* Append SubVersion revision information if available. This might be a       *)
  (* number or two numbers separated by a colon, in either case followed by one *)
  (* or more letter flags.                                                      *)

  BEGIN
    IF (fpcRev = 'exported') or (Pos('Unversioned', fpcRev) = 1) or (fpcRev = '') THEN
      RESULT:= str
    else
      RESULT:= TrimRight(str) + ' revision ' + fpcRev
  END { fpcSvn } ;


(*$ifdef HAS_SCREEN *)

  FUNCTION forcedDpi(str: STRING): STRING;

  (* If the physical DPI, read from the monitor via the widget set, is not the  *)
  (* same as that currently assumed by the forms etc. making up the GUI, then   *)
  (* append it to the name of the widget set. ScreenInfo is the lowest-level    *)
  (* portable source of this information but support for it is patchy; more     *)
  (* support was added at some point after Lazarus 1.6.4, initially for Windows *)
  (* (possibly Win-32) only.                                                    *)

  VAR   screenDpi: INTEGER= -1;         (* Read from the widget set and monitor *)
        monitorDpi: INTEGER= -1;

  BEGIN
    IF ScreenInfo.Initialized THEN
      screenDpi:= ScreenInfo.PixelsPerInchX;
    IF screenDpi = Screen.PixelsPerInch THEN (* Told us nothing useful          *)
      screenDpi:= -1;
{$if defined(TMonitorDpiType)    }
    monitorDpi:= Screen.PrimaryMonitor.PixelsPerInch;
    IF monitorDpi = Screen.PixelsPerInch THEN (* Told us nothing useful         *)
      monitorDpi:= -1;
{$endif defined(TMonitorDpiType) }
    CASE screenDpi * monitorDpi OF
      -32768..-1: RESULT := TrimRight(str) + (* -ve number, one DPI valid       *)
                    ' (' + IntToStr(screenDpi + monitorDpi + 1) + ' dpi)';
      1:          RESULT:= str;         (* 1, both DPIs invalid                 *)
    OTHERWISE                           (* Large +ve number or zero, both valid *)
      IF screenDpi = monitorDpi THEN
        RESULT := TrimRight(str) + ' (' + IntToStr(screenDpi) + ' dpi)'
      ELSE
        RESULT := TrimRight(str) + ' (' +
                IntToStr(screenDpi) + ',' + IntToStr(monitorDpi) + ' dpi)'
    END
  END { forcedDpi } ;

(*$endif HAS_SCREEN *)


BEGIN
  RESULT:= resourceVersionString;
  IF (BuildId64 <> resourceVersionInfo) AND (BuildId64 <> UnixBuild) THEN
    RESULT := RESULT + 'Build ID 0x' + HexStr(BuildId64, 16) + eol;
  IF (Trim(vcsId) <> '') AND (vcsId <> '$Id:$') THEN
    RESULT := RESULT + 'Checkout revision ' + sanitizeVcs(vcsId) + eol;
(*$IFDEF LCL *)
  IF (RevisionStr = 'exported') or (Pos('Unversioned', RevisionStr) = 1) or (RevisionStr = '') THEN
    RESULT:= RESULT + sanitize(svn(about1)) + about2b + about3 + fpcSvn(about4) + about5 + about6
  ELSE
    RESULT:= RESULT + sanitize(svn(about1)) + about2a + about3 + fpcSvn(about4) + about5 + about6;
(*$ELSE      *)
  RESULT:= RESULT + sanitize(svn(about1)) + fpcSvn(about4) + about5 + about6;
(*$ENDIF LCL *)

(* If the widget set was not known at compilation time, in principle it could   *)
(* be filled in using something like this. In practice I'm skipping this at     *)
(* least for the moment to avoid yet more dependencies on the IDE source        *)
(* directories, and I admit to being a bit dubious that Mattias's suggestion of *)
(* importing InterfaceBase and LCLPlatformDef is accurate and portable.         *)

//  IF about6 = '' THEN
//    RESULT:= RESULT + 'Running with the ' +
//                LCLPlatformDisplayNames[WidgetSet.LCLPlatform] + ' widget set';
(*$ifdef HAS_SCREEN *)
  RESULT := forcedDpi(RESULT) + eol;
  RESULT:= RESULT + 'Screen ' + DisplayIdentifier + ', displaying ' +
                IntToStr(Screen.Width) + 'x' + IntToStr(Screen.Height) +
                ' at ' + IntToStr(Screen.PixelsPerInch) + ' dpi';
(*$endif HAS_SCREEN *)
  IF appendage <> '' THEN
    RESULT:= RESULT + appendage
END { AboutText } ;


(* Everything you wanted to know about the program (but were afraid to ask).
*)
FUNCTION AboutText(CONST appendage: ARRAY OF STRING; CONST separator: STRING= '';
                                        CONST vcsId: STRING= ''): STRING;

VAR     i: INTEGER;
        scratch: STRING;

BEGIN
  scratch:= '';
  FOR i:= LOW(appendage) TO HIGH(appendage) DO
    scratch += separator + appendage[i];

(* I'm not appending a final separator (which would make it a delimiter rather  *)
(* than a separator) since if it is EOL it will add an extra line to an about   *)
(* box dialogue. For the same reason I'm assuming that the program-generated    *)
(* text (function above) doesn't have anything extra at the end.                *)

  RESULT:= AboutText(scratch, vcsId)
END { AboutText } ;


(* This is the RTL's Format(), with the following enhancements:

    %I    ISO-format date and time.
    %0I   ISO-format uncorrected data and time, i.e. UTC on most unix systems.
    %U    Decimal seconds since 1970-01-01 00:00:00.
    %0U   Decimal seconds since 1970-01-01 00:00:00, always assumed to be UTC.
    \a    Alert (bell) character. Interpretation and redirection is OS-specific
    \A    If MIDI is available, a suitable tone provided that $DISPLAY is local
    \n    Expands to LF (irrespective of operating system).
    \N    Expands to end-of-line (subject to operating system).
    \r    Expands to CR.
    \t    Expands to a single tab character.
    \T    Uses spaces to pad the preceding text to a tab position.
    \1T   Outputs a single space, then spaces to column 9 if necessary.
    \2T   Outputs a single space, then spaces to column 17 if necessary.
    \nT   As above, output a space and then pad to a tab position if necessary.
          In all cases, n must be a single digit, 0 is interpreted as 10.
    \n.xT Output x spaces after tab position n. \9.5T| puts a bar at column 78
          which, if followed by CR LF, fills an 80 character record.
    \\  Literal backslash.

  Note the distinction between the two special cases %0I and %0U, which are not
  standard Format() or printf() patterns, as compared with %0:i and %0:u which
  are. The final two optional parameters are applicable only to ISO-format
  dates.
*)
function FormatEx(const str: string; values: array of const;
                                        format: TIsoDateTimeFormat;
                                        fractionDigits: integer= 0): string;

//TODO: \a \A \n \r \T \n.xT \\

var     scratch, timeStr: string;

begin
  scratch := str;

(* Extra % format strings have to be processed before the original Format() is  *)
(* called, since it deletes what it doesn't understand.                         *)

  if Pos('%I', scratch) > 0 then begin
    timeStr := IsoFormatDateTime(Now, format, fractionDigits);
    scratch := StringReplace(scratch, '%I', timeStr, [rfReplaceAll])
  end;
  if Pos('%0I', scratch) > 0 then begin
    timeStr := IsoFormatDateTime(UTC_Now, format, fractionDigits);
    scratch := StringReplace(scratch, '%0I', timeStr, [rfReplaceAll])
  end;
  if Pos('%U', scratch) > 0 then begin
    timeStr := IntToStr(DateTimeToUnix(Now));
    scratch := StringReplace(scratch, '%U', timeStr, [rfReplaceAll])
  end;
  if Pos('%0U', scratch) > 0 then begin
    timeStr := IntToStr(DateTimeToUnix(UTC_Now));
    scratch := StringReplace(scratch, '%0U', timeStr, [rfReplaceAll])
  end;
  result := Sysutils.Format(scratch, values);

(* Backslash escaped characters or sequences have to be processed after         *)
(* Format() has expanded all printable output.                                  *)

  result := StringReplace(result, '\t', #$09, [rfReplaceAll]);
  result := StringReplace(result, '\N', #$0d + #$0a, [rfReplaceAll])
end { FormatEx } ;


(* This is the RTL's Format(), with the following enhancements:

    %I    ISO-format date and time.
    %0I   ISO-format uncorrected data and time, i.e. UTC on most unix systems.
    %U    Decimal seconds since 1970-01-01 00:00:00.
    %0U   Decimal seconds since 1970-01-01 00:00:00, always assumed to be UTC.
    \a    Alert (bell) character. Interpretation and redirection is OS-specific
    \A    If MIDI is available, a suitable tone provided that $DISPLAY is local
    \n    Expands to LF (irrespective of operating system).
    \N    Expands to end-of-line (subject to operating system).
    \r    Expands to CR.
    \t    Expands to a single tab character.
    \T    Uses spaces to pad the preceding text to a tab position.
    \1T   Outputs a single space, then spaces to column 9 if necessary.
    \2T   Outputs a single space, then spaces to column 17 if necessary.
    \nT   As above, output a space and then pad to a tab position if necessary.
          In all cases, n must be a single digit, 0 is interpreted as 10.
    \n.xT Output x spaces after tab position n. \9.5T| puts a bar at column 78
          which, if followed by CR LF, fills an 80 character record.
    \\  Literal backslash.

  Note the distinction between the two special cases %0I and %0U, which are not
  standard Format() or printf() patterns, as compared with %0:i and %0:u which
  are. The final optional parameter is applicable only to ISO-format dates.
*)
function FormatEx(const str: string; values: array of const;
                                        fractionDigits: integer= 0): string;

begin
  result := FormatEx(str, values, IsoDateTime, fractionDigits)
end { FormatEx } ;


initialization
{$ifopt C+ Predicated on assertions generating code }
  testIso
{$endif }
end.

