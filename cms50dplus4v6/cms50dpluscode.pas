(* Lazarus+FPC 2.1.0+3.2.0 on Linux Lazarus+FPC 2.1.0+3.2.0 on Linux Lazarus+FP *)

unit cms50dpluscode;

(* GUI program to read live data from a Contec CMS50D+ pulse oximeter (firmware *)
(* v4.6, 9-byte messages @115k). Since these are being widely used to monitor   *)
(* health during the current COVID-19 pandemic and in the hope that speedy      *)
(* release might benefit somebody, this borrows heavily from my earlier code to *)
(* read a Mastech MS2115B meter, styled on Mastech's supplied Windows-only      *)
(* application.                                                 MarkMLl         *)

// TODO : Save-to-file etc.

{$mode objfpc}{$H+}

interface

uses
  Classes, SysUtils, Forms, Controls, Graphics, Dialogs, Menus, PairSplitter,
  ComCtrls, Grids, StdCtrls, ExtCtrls, TAGraph, TAIntervalSources, TASeries;

type
  String15= string[15];

  { TCMS50DPlusForm }

  TCMS50DPlusForm = class(TForm)
    Chart1: TChart;
    Chart1LineSeries1: TLineSeries;
    Chart1LineSeries2: TLineSeries;
    Chart1LineSeries3: TLineSeries;
    DateTimeIntervalChartSource1: TDateTimeIntervalChartSource;
    GroupBoxReading: TGroupBox;
    ImageList1: TImageList;
    LabelChartSize: TLabel;
    LabelReadingTop: TLabel;
    LabelReadingBottom: TLabel;
    LabelReadingMiddle: TLabel;
    MainMenu1: TMainMenu;
    MenuItem1: TMenuItem;
    MenuItem2: TMenuItem;
    MenuItem3: TMenuItem;
    MenuItem4: TMenuItem;
    MenuItemExportImageGif: TMenuItem;
    MenuItemExportImagePng: TMenuItem;
    MenuItemExportImage: TMenuItem;
    MenuItemStopLog: TMenuItem;
    MenuItemDump: TMenuItem;
    MenuItemLog: TMenuItem;
    MenuItemRunStop: TMenuItem;
    MenuItemRunStart: TMenuItem;
    MenuItemHelp: TMenuItem;
    MenuItemSetport: TMenuItem;
    MenuItemRun: TMenuItem;
    MenuItemFileExit: TMenuItem;
    MenuItemFile: TMenuItem;
    PairSplitterLR: TPairSplitter;
    PairSplitterLTB: TPairSplitter;
    PairSplitterLRLeft: TPairSplitterSide;
    PairSplitterLRRight: TPairSplitterSide;
    PairSplitterLTBTop: TPairSplitterSide;
    PairSplitterLTBBottom: TPairSplitterSide;
    SaveDialog1: TSaveDialog;
    StringGridLog: TStringGrid;
    ToolBar1: TToolBar;
    ToolButtonFileSave: TToolButton;
    ToolButtonFilePrint: TToolButton;
    ToolButtonRunStart: TToolButton;
    ToolButtonRunStop: TToolButton;
    ToolButtonWhatsThis: TToolButton;
    ToolButtonFileSeparator1: TToolButton;
    ToolButtonFileSeparator2: TToolButton;
    ToolButtonFileNew: TToolButton;
    ToolButtonFileOpen: TToolButton;
    procedure Chart1Resize(Sender: TObject);
    procedure FormCloseQuery(Sender: TObject; var CanClose: Boolean);
    procedure FormCreate(Sender: TObject);
    procedure LabelChartSizeDblClick(Sender: TObject);
    procedure MenuItemExportImagePngClick(Sender: TObject);
    procedure MenuItemFileExitClick(Sender: TObject);
    procedure MenuItemFileNewClick(Sender: TObject);
    procedure MenuItemFileOpenClick(Sender: TObject);
    procedure MenuItemRunStartClick(Sender: TObject);
    procedure MenuItemRunStopClick(Sender: TObject);
  strict private
    widthTweak, heightTweak: integer;

    (* This is called when the wm_After_Show message is dequeued, which is
      guaranteed to be after form creation has completed.
    *)
    procedure OnAfterShow(afterShowParam: PtrInt);
  protected
    fcommsThread: TThread;

    (* Output the values read from the meter in text form. This is called, via
      Synchronize(), by the background communications thread.
    *)
    procedure ReadingTxt(const time, spo2, bpm, sig, ir, vis, status: string15);

    (* Output the values read from the meter in binary form for the chart etc.
      This is called, via Synchronize(), by the background communications thread.
    *)
    procedure ReadingBin(timestamp: TDateTime; ir, vis, spo2: double);
  public

    (* This is the default port name, generated by looking for a serial device
      using the Linux cp210x kernel module.

      This illustrates one of my gripes about Object Pascal: I want this to be
      settable from the main unit (project file) only, but there is insufficient
      protection available to enforce this. The best that could be done would be
      to set up a property which detects if it has already been set, but that
      would need an extra field (or reserved string) to detect that it had been
      set to a "no port" value... all in all the hassle isn't worth it.
    *)
    DefaultPort: string;

    (* Return the apparent size of the specified control, as a formatted string.
    *)
    function GraphicSize(ctrl: TWinControl): string;

    (* Message box optimised for position.
    *)
    FUNCTION MessageDlgOpt(CONST aMsg: STRING; dlgType: TMsgDlgType;
                            buttons: TMsgDlgButtons; helpCtx: LONGINT): INTEGER;

  end;

var
  CMS50DPlusForm: TCMS50DPlusForm;


implementation

{$R *.lfm}

uses
  Serial, BaseUnix, Termio, ConsoleApp, LocateCp210xPort, IniFilesAbout, StrUtils;

const
  ProjName= 'CMS50DPlus';
  CMS50DPlusCodeMagicNumber= 2020012719;

(********************************************************************************)

type
  TcommsThread= class(TThread)
  strict private
    serialHandle: TSerialHandle;
    messageStr: string;
    procedure msgShim;
  protected
    procedure Execute; override;
  public
    constructor Create(CreateSuspended: Boolean; mySerialHandle: TSerialHandle);
    procedure writerShim;
  end;

  TCMS50DPlusFormH=                     (* Avoid circular definition            *)
    class helper for TCMS50DPlusForm
    protected
      function CommsThread(): TCommsThread; inline;
    end;


(* This helper avoids problems with circular references, in particular many
  occurrences of things like TCommsThread(CMS50DPlusForm.CommsThread).Synchronize()
  in favour of the somewhat more concise CMS50DPlusForm.CommsThread.Synchronize().
*)
function TCMS50DPlusFormH.CommsThread(): TCommsThread; inline;

begin
  result := fCommsThread as TcommsThread
end { TCMS50DPlusFormH.CommsThread } ;


(* These are used to pass values between the background thread and the main     *)
(* (GUI) thread. They'd normally be local to the thread object, but can't be in *)
(* this case since the RunConsoleApp2() function hence the writer callback are  *)
(* "traditional" Pascal rather than being "methods" in an object.               *)

var
  time, spo2, bpm, sig, ir, vis, extra: string15;
  irBin, visBin, spo2Bin: double;
  stopLoop: boolean= false;


constructor TcommsThread.Create(CreateSuspended: Boolean; mySerialHandle: TSerialHandle);

begin
  inherited Create(CreateSuspended);
  FreeOnTerminate := true;
  serialHandle := mySerialHandle
end { TcommsThread.Create } ;


(* Provided that it is called via Synchronize(), this executes in the context of
  the main (GUI) thread.
*)
procedure TcommsThread.msgShim;

begin
  CMS50DPlusForm.MessageDlgOpt(messageStr, mtError, [mbOk], 0);
  CMS50DPlusForm.MenuItemRunStopClick(nil) (* Help GUI recover from error       *)
end { TcommsThread.msgShim } ;


(* Provided that it is called via Synchronize(), this executes in the context of
  the main (GUI) thread.
*)
procedure TcommsThread.writerShim;

begin
  CMS50DPlusForm.ReadingTxt(time, spo2, bpm, sig, ir, vis, extra);
  CMS50DPlusForm.ReadingBin(Now(), irBin, visBin, spo2Bin);

(* Slightly messy: if there isn't an OK message then the comms thread might     *)
(* have terminated since the meter has come to the end of a 30 sec reading, at  *)
(* which point the thread- as requested- self-destructs. But the stop button    *)
(* handler might also refer to the thread to try to terminate it, resulting in  *)
(* an exception which needs to be caught and rendered harmless.                 *)

  if Pos('OK', extra) = 0 then
    CMS50DPlusForm.MenuItemRunStopClick(nil) (* Ready for repeat reading        *)
end { TcommsThread.writerShim } ;


(* This is called by the datacomms loop in the datacomms thread roughly every
  half second, and passes the unpacked data to the main (GUI) thread via
  Synchronize() and a shim procedure (immediately above).
*)
procedure writer(const s: string);

// This isn't very efficient since it is basically processing text output which
// has been parsed and scaled from the binary data received from meter, but
// since this is a background thread I'm not particularly bothered by that.

begin
  time := Trim(ExtractWord(1, s, ['|']));
  spo2 := Trim(ExtractWord(6, s, ['|']));
  bpm := Trim(ExtractWord(5, s, ['|']));
  sig := Trim(ExtractWord(2, s, ['|']));
  ir := Trim(ExtractWord(3, s, ['|']));
  vis := Trim(ExtractWord(4, s, ['|']));
  extra := Trim(ExtractWord(7, s, ['|']));
  irBin := StrToFloat(ir);
  visBin := StrToFloat(vis);
  spo2Bin := StrToFloat(spo2);
  CMS50DPlusForm.CommsThread.Synchronize(@CMS50DPlusForm.CommsThread.writerShim)
end { writer } ;


(* Main datacomms code. Because RunConsoleApp2() may run either in the context
  of this background thread or a simple console program, its writer parameter
  is a top-level procedure rather than being a method in the thread.
*)
procedure TcommsThread.Execute;

begin
  case RunConsoleApp2(serialHandle, stopLoop, @writer) of
    3: messageStr := 'No data waiting for sync byte';
    4: messageStr := 'No data reading message';
    5: messageStr := 'Error formatting message'
  otherwise
    messageStr := ''
  end;
  if (messageStr <> '') and not stopLoop then
    Synchronize(@msgShim);
  messageStr := ''
end { TcommsThread.Execute } ;


(********************************************************************************)

const
  topStandardSize= 8;

type
  TstandardSizeUnit= (ssPx, ssIn, ssMm);

type
  TstandardSize= record
                   name: string[62];
                   ssUnit: TstandardSizeUnit;
                   width, height: integer;
                   widthPx, heightPx: integer
                 end;

var
  standardSizes: array[0..topStandardSize] of TStandardSize;


(* Initialise the array which defines plausible page sizes for exported
  graphical output.
*)
procedure initPageSizes;

begin
    with standardSizes[0] do begin
    name := '4x3"';
    ssUnit := ssIn;
    width := 4;
    height := 3
  end;
  with standardSizes[1] do begin
    name := '5x4"';
    ssUnit := ssIn;
    width := 5;
    height := 4
  end;
  with standardSizes[2] do begin
    name := '7x5"';
    ssUnit := ssIn;
    width := 7;
    height := 5
  end;
  with standardSizes[3] do begin
    name := '640x480';
    ssUnit := ssPx;
    width := 640;
    height := 480
  end;
  with standardSizes[4] do begin
    name := '800x600';
    ssUnit := ssPx;
    width := 800;
    height := 600
  end;
  with standardSizes[5] do begin
    name := '1024x768';
    ssUnit := ssPx;
    width := 1024;
    height := 768
  end;
  with standardSizes[6] do begin
    name := 'ISO A5';
    ssUnit := ssMm;
    width := 210;
    height := 148
  end;
  with standardSizes[7] do begin
    name := 'ISO A6';
    ssUnit := ssIn;
    width := 148;
    height := 105
  end;
  with standardSizes[8] do begin
    name := 'ISO A7';
    ssUnit := ssIn;
    width := 105;
    height := 74
  end
end { initPageSizes } ;


(* Immediately before the page size array is referred to in a resize operation,
  make sure that sizes are updated using the current DPI setting where needed.
*)
procedure scalePageSizes;

var
  i: integer;

begin
  for i := 0 to topStandardSize do
    with standardSizes[i] do
      case ssUnit of
        ssIn: begin
                widthPx := width * Screen.PrimaryMonitor.PixelsPerInch;
                heightPx := height * Screen.PrimaryMonitor.PixelsPerInch
              end;
        ssMm: begin
                widthPx := Round((width * Screen.PrimaryMonitor.PixelsPerInch) / 25.4);
                heightPx := Round((height * Screen.PrimaryMonitor.PixelsPerInch) / 25.4)
              end
      otherwise
        widthPx := width;
        heightPx := height
      end
end { scalePageSizes } ;


(********************************************************************************)


{ TCMS50DPlusForm }


procedure TCMS50DPlusForm.MenuItemFileNewClick(Sender: TObject);
begin

end { TCMS50DPlusForm.MenuItemFileNewClick } ;


procedure TCMS50DPlusForm.MenuItemFileExitClick(Sender: TObject);

begin
  Close
end { TCMS50DPlusForm.MenuItemFileExitClick } ;


procedure TCMS50DPlusForm.FormCloseQuery(Sender: TObject; var CanClose: Boolean);

var
  temp: string;

begin
  temp:= Application.MainForm.Caption;
  IF Pos(' ', temp) > 0 THEN
    SetLength(temp, Pos(' ', temp) - 1);
  temp:= 'Terminate ' + temp + '?';
  CanClose:= MessageDlgOpt(temp, mtWarning, [mbYes, mbNo], 0) = mrYes
end { TCMS50DPlusForm.FormCloseQuery } ;


(* Return the apparent size of the specified control, as a formatted string.
*)
function TCMS50DPlusForm.GraphicSize(ctrl: TWinControl): string;

var
  nearestDistance, currentDistance: single;
  nearestIndex, i: integer;

begin
  scalePageSizes;                       (* DPI might change during program execution *)

(* Find the standard-size corner nearest to the current control corner.         *)

  nearestIndex := 0;
  nearestDistance := 1.0E99;
  for i := 0 to topStandardSize do begin
    currentDistance := Sqrt(Sqr(ctrl.Width - standardSizes[i].widthPx) + Sqr(ctrl.Height - standardSizes[i].heightPx));
    if currentDistance < nearestDistance then begin
      nearestIndex := i;
      nearestDistance := currentDistance
    end
  end;

(* I'd prefer to use Format() right through here but I don't trust the FPC      *)
(* implementation (or for that matter my own extensions) to reliably give me    *)
(* signed +ve integers where I want them. The tweaks are saved since they will  *)
(* be needed if the user wants to snap the control to a standard size before    *)
(* exporting it, they are used here to indicate how much bigger the control is  *)
(* than a standard size so if used to adjust the size they are subtracted.      *)

  widthTweak := ctrl.Width - standardSizes[nearestIndex].widthPx;
  heightTweak := ctrl.Height - standardSizes[nearestIndex].heightPx;
  result := Format('%d×%d (%s', [ctrl.Width, ctrl.Height, standardSizes[nearestIndex].name]);
  if (widthTweak <> 0) or (heightTweak <> 0) then begin
    result += ' ';
    if ctrl.Width >= standardSizes[nearestIndex].widthPx then
      result += '+';
    result += IntToStr(widthTweak) + '×';
    if ctrl.Height >= standardSizes[nearestIndex].heightPx then
      result += '+';
    result += IntToStr(heightTweak)
  end;
  result += ')'
end { TCMS50DPlusForm.GraphicSize } ;


procedure TCMS50DPlusForm.Chart1Resize(Sender: TObject);

begin
  LabelChartSize.Caption := GraphicSize(Chart1);
  LabelChartSize.Top := Chart1.Top;
  LabelChartSize.Left := Chart1.Left + (Chart1.Width - Chart1.AxisList[2].LabelSize) -
                                                        LabelChartSize.Width
end { TCMS50DPlusForm.Chart1Resize } ;


(* This is called when the wm_After_Show message is dequeued, which is
  guaranteed to be after form creation has completed.
*)
procedure TCMS50DPlusForm.OnAfterShow(afterShowParam: PtrInt);

var
  i: integer;
  portNames: TStringList;

begin
  Assert(afterShowParam = CMS50DPlusCodeMagicNumber, 'Internal error: TCMS50DPlusForm bad magic number');

(* Initialise the menu from the known ports. The first port in the list is      *)
(* selected as the initial default, then this is changed to the "best" one e.g. *)
(* /dev/ttyUSB0.                                                                *)

  portNames := ListPorts();
  try
    for i := 0 to portNames.Count - 1 do begin
      MenuItemSetPort.Add(TMenuItem.Create(nil));
      with MenuItemSetPort.Items[i] do begin
        Caption := portnames[i];
        GroupIndex := 1;
        RadioItem := true;
        Checked := (i = 0) or (Caption = DefaultPort);
        AutoCheck := true
      end
    end;
    MenuItemRun.Enabled := portNames.Count > 0;
    MenuItemRunStart.Enabled := MenuItemRun.Enabled
  finally
    FreeAndNil(portNames)
  end;
  LabelChartSize.Parent := Chart1;      (* Dont change in resize event, assume  *)
  LabelChartSize.Color := Chart1.BackColor (* it will be called imminently.     *)
end { TCMS50DPlusForm.OnAfterShow } ;


procedure TCMS50DPlusForm.FormCreate(Sender: TObject);

begin

  Application.QueueAsyncCall(@OnAfterShow, CMS50DPlusCodeMagicNumber) (* Keep at end *)
end { TCMS50DPlusForm.FormCreate } ;


(* Double-click on the label which displays the graphic size to resize the main
  form in order to make the graphic size standard for easy insertion in a
  notenook etc.
*)
procedure TCMS50DPlusForm.LabelChartSizeDblClick(Sender: TObject);

begin

(* The tweak values are set by a TAChart resize operation, of which there will  *)
(* always be at least one (at program start).                                   *)

  Application.MainForm.Width := Application.MainForm.Width - widthTweak;
  widthTweak := 0;
  Application.MainForm.Height := Application.MainForm.Height - HeightTweak;
  heightTweak := 0
end { TCMS50DPlusForm.LabelChartSizeDblClick } ;


procedure TCMS50DPlusForm.MenuItemExportImagePngClick(Sender: TObject);

var
  nameBlank: boolean;
  png: TPortableNetworkGraphic;
  everything: TRect;

begin
  nameBlank := Trim(SaveDialog1.Filename) = '';
  if nameBlank then
    SaveDialog1.Filename := projName + '_' + StringReplace(IsoNow(), ' ', 'T', [rfReplaceAll]);
  SaveDialog1.DefaultExt := 'png';

(* Possibly replace this later with a custom setup form to select compression   *)
(* etc.                                                                         *)

  if SaveDialog1.Execute then begin
    png := TPortableNetworkGraphic.Create;
    try
      png.Width := Chart1.Width;
      png.Height := Chart1.Height;
      everything.Left := 0;
      everything.Top := 0;
      everything.Right := Chart1.Width - 1;
      everything.bottom := Chart1.Height - 1;
      png.Canvas.CopyRect(everything, Chart1.Canvas, everything);
      png.SaveToFile(SaveDialog1.Filename)
    finally
      png.Free
    end
  end;
  if nameBlank then
    SaveDialog1.Filename := ''
end { TCMS50DPlusForm.MenuItemExportImagePngClick } ;


procedure TCMS50DPlusForm.MenuItemFileOpenClick(Sender: TObject);

begin

end { TCMS50DPlusForm.MenuItemFileOpenClick } ;


procedure TCMS50DPlusForm.MenuItemRunStartClick(Sender: TObject);

var
  i: integer;
  portName: string= '';
  portHandle: TSerialHandle= InvalidSerialHandle;

begin
  for i := 0 to MenuItemSetPort.Count - 1 do
    if MenuItemSetPort.Items[i].Checked then
      portName := MenuItemSetPort.Items[i].Caption;
  if portName = '' then
    exit;
  portHandle := SerOpen(portName);      (* Configured and closed by thread      *)
{$ifdef UNIX }
  if portHandle > 0 then
    if fpIoctl(portHandle, TIOCEXCL, nil) <> 0 then begin (* Mandatory lock,    *)
      SerClose(portHandle);             (* unlike flock() (if it even works in  *)
      portHandle := InvalidSerialHandle (* this context) or a lock file as used *)
    end;                                (* by various gettys etc.               *)
{$endif UNIX }
  stopLoop := false;
  if portHandle <> InvalidSerialHandle then begin
    GroupBoxReading.Caption := 'Reading';
    MenuItemRunStart.Enabled := false;
    StringGridLog.RowCount := 1;

(* The thread should free itself on termination. I'm going to be somewhat       *)
(* naughty and assume this is done correctly.                                   *)

    fcommsThread := TcommsThread.Create(false, portHandle);
    MenuItemRunStop.Enabled := true
  end
end { TCMS50DPlusForm.MenuItemRunStartClick } ;


procedure TCMS50DPlusForm.MenuItemRunStopClick(Sender: TObject);

begin
  MenuItemRunStop.Enabled := false;
  try
    fcommsThread.Terminate              (* Leaves field containing rubbish      *)
  except

(* This handles the possibilty of the exec procedure already having fallen out  *)
(* of the bottom (hence the thread self-destructing as requested) due to normal *)
(* termination of a 30-second reading.                                          *)

  end;
  stopLoop := true;                     (* Makes sure thread loop exits promptly *)
  fcommsThread := nil;
  GroupBoxReading.Caption := 'Paused';
  MenuItemRunStart.Enabled := true
end { TCMS50DPlusForm.MenuItemRunStopClick } ;


(* Output the values read from the meter in text form. This is called, via
  Synchronize(), by the background communications thread.
*)
procedure TCMS50DPlusForm.ReadingTxt(const time, spo2, bpm, sig, ir, vis, status: string15);

var
  currentRow: integer;


  function spaceBeforeUnit(const s: string): string;

  var
    i: integer;

  begin
    result := s;
    if Pos(' ', result) <= 0 then
      for i := 2 to Length(s) do
        if (s[i - 1] in ['.', '0'..'9']) and not (s[i] in ['.', '0'..'9']) then begin
          insert(' ', result, i);
          break
        end
  end { spaceBeforeUnit } ;


begin
  if StringGridLog.RowCount >= 1000 + 125 then
    while StringGridLog.RowCount > 1000 - 125 do
      StringGridLog.DeleteRow(1);
  currentRow := StringGridLog.RowCount;
  StringGridLog.RowCount := currentRow + 1;
  StringGridLog.Row := currentRow + 1;
  with StringGridLog do begin
    Cells[0, currentRow] := time;
    Cells[1, currentRow] := spo2;
    Cells[2, currentRow] := bpm;
    Cells[3, currentRow] := sig;
    Cells[4, currentRow] := ir;
    Cells[5, currentRow] := vis
  end;
  LabelReadingTop.Caption := bpm + ' BPM';
  LabelReadingMiddle.Caption := spo2 + ' %';
  LabelReadingBottom.Caption := status
end { TCMS50DPlusForm.ReadingTxt } ;


(* Output the values read from the meter in binary form for the chart etc.
  This is called, via Synchronize(), by the background communications thread.
*)
procedure TCMS50DPlusForm.ReadingBin(timestamp: TDateTime; ir, vis, spo2: double);

var
  i: integer;

begin
  if Chart1LineSeries1.Count = 0 then   (* Make startup a bit more predictable  *)
    for i := -99 to 0 do begin
      Chart1LineSeries1.AddXY(Now() + (0.5 * i / SecsPerDay), spo2);
      Chart1LineSeries2.AddXY(Now() + (0.5 * i / SecsPerDay), ir);
      Chart1LineSeries3.AddXY(Now() + (0.5 * i / SecsPerDay), vis)
    end;
  while Chart1LineSeries1.Count >= 100 + 4 do
    while Chart1LineSeries1.Count > 100 - 4 do begin
      Chart1LineSeries1.Delete(0);
      Chart1LineSeries2.Delete(0);
      Chart1LineSeries3.Delete(0)
    end;
  Chart1LineSeries1.AddXY(timestamp, spo2);
  Chart1LineSeries2.AddXY(timestamp, ir);
  Chart1LineSeries3.AddXY(timestamp, vis)
end { TCMS50DPlusForm.ReadingBin } ;


(* Message box optimised for position.
*)
FUNCTION TCMS50DPlusForm.MessageDlgOpt(CONST aMsg: STRING; dlgType: TMsgDlgType;
                        buttons: TMsgDlgButtons; helpCtx: LONGINT): INTEGER;

VAR     x, y: INTEGER;

BEGIN
  x:= (Left + Width DIV 2 + Screen.Width DIV 2) DIV 2;
  y:= (Top + Height DIV 2 + Screen.Height DIV 2) DIV 2;
  RESULT:= MessageDlgPos(aMsg, dlgType, buttons, helpCtx, x, y)
END { TCMS50DPlusForm.MessageDlgOpt } ;


initialization
  initPageSizes
end.

